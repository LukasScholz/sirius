import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption

buildscript {
    repositories {
        maven { url "https://plugins.gradle.org/m2/" }
        maven { url "http://bio.informatik.uni-jena.de/repository/local" }
    }
    dependencies {
        classpath group: 'de.unijena.bioinf.gradle', name: 'launch4jj', version: '1.6.2'
        classpath "com.github.jengelman.gradle.plugins:shadow:1.2.3"
    }

}

/*plugins {
    id "com.jfrog.artifactory" version "4.3.0"
}*/

//Global Properties
ext {
    //version for external libraries

    json_version = '1.0'
    json_impl_version = "1.0.4"

    glpk_lib_version = '4.60'

    jewelcli_version = '0.8.+'
    gurobi_version = '6.5.1'
    siriusVersion = '3.2.1-SNAPSHOT'
    fingeridVersion = "1.0.6-SNAPSHOT"

    //locations of runtime libraries
    runtimeClasspath = '${GUROBI_HOME}/lib/gurobi.jar'
    gurobiExclude = "gurobi-*-${gurobi_version}.jar"
}

allprojects {
//    apply plugin: "com.jfrog.artifactory"
    apply plugin: 'java'
//    apply plugin: 'maven-publish'

    sourceCompatibility = 1.7
    targetCompatibility = 1.7


    version = '3.2.1-SNAPSHOT'
    group = 'de.unijena.bioinf.ms'

    repositories {
        mavenLocal()
        mavenCentral()
        maven {
            url "https://bio.informatik.uni-jena.de/repository/local"
        }
        maven {
            url "http://www.ebi.ac.uk/intact/maven/nexus/content/repositories/ebi-repo"
        }
        maven {
            url "https://www.xypron.de/repository" //glpk repo
        }

    }

    dependencies {
        compile 'net.sf.trove4j:trove4j:3.0.3'
        compile 'com.google.guava:guava:18.0'

        testCompile group: 'junit', name: 'junit', version: '4.+'
    }
}

task downloadGLPK(type: Copy) {
    def glpkURL = new URL("https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/glpk/glpk-${project.glpk_lib_version}.zip")
    project.ext.set("glpkPath", getBuildDir().toPath().resolve('tmp/glpk/').toFile())

    java.nio.file.Path dir = project.glpkPath.toPath().getParent()

    copy {
        println(dir.toString())
        dir.resolve('glpk').toFile().deleteDir()
        Files.createDirectories(dir)

        def glpkZipFile = Paths.get('glpk.zip');
        def file = dir.resolve(glpkZipFile).newOutputStream()
        file << glpkURL.openStream()
        file.close()

        from zipTree(dir.resolve(glpkZipFile).toFile())
        into dir.toFile()
    }
}

/*################### DISTRIBUTION STUFF ################### */



project.ext.set("linSuffix", "linux")
project.ext.set("winSuffix", "win")
project.ext.set("macSuffix", "osx")
project.ext.set("arch", "64,32")
project.ext.set("appName", "sirius3")
project.ext.set("manualPath", file('manual').absolutePath)
project.ext.set("distPath", file('dist').absolutePath)

/*################### Building the Documentation ################### */


task cleanDoku(type: Exec) {
    group = 'documentation'
    workingDir = file("${project.manualPath}")
    commandLine(['make', 'clean'])
}

task htmlDoku(type: Exec) {
    group = 'documentation'
    workingDir = file("${project.manualPath}")
    commandLine(['make', 'html'])
}
htmlDoku.mustRunAfter cleanDoku

task textDoku(type: Exec) {
    group = 'documentation'
    workingDir = file("${project.manualPath}")
    commandLine(['make', 'text'])
}
textDoku.mustRunAfter cleanDoku

task pdfDoku(type: Exec) {
    group = 'documentation'
    workingDir = file("${project.manualPath}")
    commandLine(['make', 'latexpdf'])
}
pdfDoku.mustRunAfter cleanDoku



File out = file("${project.manualPath}/build/singleText/sirius.rst")
File md = file("${project.manualPath}/build/singleText/sirius.md")

task buildDoku(type: Exec) {
    group = 'documentation'
    workingDir = file("${project.manualPath}")
    commandLine(['pandoc', '-f', 'rst', '-t', 'markdown', '-o', "${md}", "${out}"])
}

buildDoku.doFirst {
    def f = file("${project.manualPath}/source/index.rst").readLines()
    out.toPath().getParent().toFile().mkdirs();
    out.createNewFile()

    //todo do we want the index file here?
    /*file("${project.manualPath}/build/text/index.txt").withInputStream() {
        out << it
    } */

    f.each {
        File ff = file("${project.manualPath}/build/text/${it.trim()}.txt")
        if (ff.exists()) {
            logger.lifecycle("Appending File: ${ff}")
            ff.withInputStream() {
                out << it
            }
        }
    }

}
buildDoku.doLast {
    logger.lifecycle("copying ${md} to preject root")
    Files.copy(md.toPath(), file('../README.md').toPath(), StandardCopyOption.REPLACE_EXISTING)
}

buildDoku.dependsOn cleanDoku, htmlDoku, textDoku, pdfDoku
clean.dependsOn cleanDoku


subprojects {
    apply plugin: 'application'
    apply plugin: 'de.unijena.bioinf.launch4jj'

    /*################### Windows release Stuff ################### */
    launch4j {
        icon = file('../dist/sirius.ico')
        copyright = "Chair of Bioinformatics, Friedrich-Schiller-University Jena."
        companyName = "Friedrich-Schiller-University Jena"
        version = project.version
        textVersion = project.version
        supportUrl = "https://bio.informatik.uni-jena.de/software/sirius/"

        initialHeapPercent = 50
        maxHeapPercent = 80

        dontWrapJar = true
        jdkPreference = "preferJre"

        classPath = ["${runtimeClasspath.replace('${', '%').replace('}', '%')}"]

    }

    /*################### Linux release Stuff ################### */
    startScripts {
        applicationName = "${project.appName}"
        doLast {
            def siriusLibPath = '$GUROBI_HOME/lib:$APP_HOME/lib'
            unixScript.text = unixScript.text.replace('CLASSPATH=', "CLASSPATH=${runtimeClasspath}:")
            unixScript.text = unixScript.text.replace('DEFAULT_JVM_OPTS=""', 'export LD_LIBRARY_PATH=' + siriusLibPath + ':$LD_LIBRARY_PATH' + "${System.lineSeparator()}" + 'DEFAULT_JVM_OPTS="-Djava.library.path=' + siriusLibPath + '"')
        }
    }

    /*################### Build distributions ################### */
    task distribute { group = 'distribution' }
    distribute.dependsOn buildDoku
}
