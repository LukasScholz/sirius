import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform

import java.lang.reflect.Array
import java.nio.file.Paths

plugins {
    id 'org.beryx.runtime' version '1.11.4'
}

ext {
    OS = DefaultNativePlatform.currentOperatingSystem

    if (OS.isLinux()) {
        nativeLibs = 'l64'
        osName = 'linux64'
        zosName = 'linux'
        installerNameType = 'deb'
        installerAppendix = "_${version}-1_amd64.$installerNameType"
    } else if (OS.isWindows()) {
        nativeLibs = 'w64'
        osName = 'win64'
        zosName = 'win'
        installerNameType = 'msi'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType"
    } else if (OS.isMacOsX()) {
        nativeLibs = 'osx'
        osName = 'osx64'
        zosName = 'macosx'
        installerNameType = 'pkg'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType"
    }
}

task downloadJDK(type: Download) {
    String fname = "zulu${zulu_jre_version}-ca-fx-jdk${jre_version}-${zosName}_x64"
    String ext = ".${OS.isWindows() ? 'zip' : 'tar.gz'}";
    project.ext.set("jdkPath", getBuildDir().toPath().resolve(fname).toFile())


    src "https://bio.informatik.uni-jena.de/repository/list/ext-release-local/zulu/fx-jdk/${zulu_jre_version}/${fname + ext}"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname + ext).toFile()
    onlyIfModified true
    overwrite false
}

task extractJDK(type: Copy, dependsOn: downloadJDK) {
    def s = downloadJDK.outputs.files.singleFile
    println(s)
    if (s.getName().endsWith('.zip')) {
        outputs.file(s.absolutePath.replace('.zip', ''))
        from zipTree(s)
    } else {
        outputs.file(s.absolutePath.replace('.tar.gzip', ''))
        from tarTree(resources.gzip(s))
    }
    into buildDir
}

task createRuntimeImgs(dependsOn: extractJDK) {
    String[] baseModules = ['java.sql', 'java.logging', 'jdk.jsobject', 'java.xml', 'jdk.xml.dom', 'java.datatransfer',
                            'java.naming', 'java.prefs', 'java.instrument']
    String[] fxModules = baseModules +
            ['java.desktop', 'javafx.base', 'javafx.web', 'javafx.graphics', 'javafx.swing', 'javafx.controls']

    File jlink = jdkPath.toPath().resolve('bin').resolve(OS.isWindows() ? 'jlink.exe' : 'jlink').toFile()
    File outFX = buildDir.toPath().resolve('runtime').resolve("sirius-${jlink.toPath().getParent().getParent().getFileName().toString()}").toFile()
    File outheadl = Paths.get(outFX.absolutePath.replace('-fx-', '-headless-')).toFile()
    outputs.files(outFX, outheadl)

    String[] args = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']

    doLast {
        exec {
            String[] c = [jlink.absolutePath, '--add-modules', "${baseModules.join(',')}", '--output', outheadl.absolutePath]
            commandLine(c + args)
        }
        exec {
            String[] c = [jlink.absolutePath, '--add-modules', "${fxModules.join(',')}", '--output', outFX.absolutePath]
            commandLine(c + args)
        }
    }
}


task downloadGLPK(type: Download) {
    project.ext.set("glpkPath", getBuildDir().toPath().resolve('glpk').toFile())
    String fname = "glpk-${project.glpk_lib_version}.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/glpk/$fname"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname).toFile()
    onlyIfModified true
    overwrite false
    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking GLPK...")
                from zipTree(outputs.files.singleFile)
                into buildDir
            }
        } else {
            getLogger().lifecycle("Unpacking GLPK SKIPPED")
        }
    }
}

task downloadCLP(type: Download) {
    project.ext.set("clpPath", getBuildDir().toPath().resolve('clp').toFile())
    String fname = "clp-${project.clp_lib_version}.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/clp/$fname"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname).toFile()
    onlyIfModified true
    overwrite false
    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking CPL...")
                from zipTree(outputs.files.singleFile)
                into buildDir

            }
        } else {
            getLogger().lifecycle("Unpacking CPL SKIPPED")
        }
    }
}


task downloadRuntimeImageFX(type: Download) {
    String fname = "sirius-zulu${zulu_jre_version}-ca-fx-jdk${jre_version}-${zosName}_x64.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/jre/${zulu_jre_version}/${fname}"
    dest getBuildDir().toPath().resolve('runtime').resolve(fname).toFile()
    onlyIfModified true
    overwrite false

    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking runtime image fx...")
                from zipTree(outputs.files.singleFile)
                into getBuildDir().toPath().resolve('runtime').toFile()

            }
        } else {
            getLogger().lifecycle("Unpacking runtime image fx SKIPPED")
        }
    }
}

task downloadRuntimeImageHeadless(type: Download) {
    String fname = "sirius-zulu${zulu_jre_version}-ca-headless-jdk${jre_version}-${zosName}_x64.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/jre/${zulu_jre_version}/${fname}"
    dest getBuildDir().toPath().resolve('runtime').resolve(fname).toFile()
    onlyIfModified true
    overwrite false

    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking runtime image headless...")
                from zipTree(outputs.files.singleFile)
                into getBuildDir().toPath().resolve('runtime').toFile()

            }
        } else {
            getLogger().lifecycle("Unpacking runtime image headless SKIPPED")
        }
    }
}

task downloadManual(type: Download, group: 'documentation') {
    String manualName = "manual-$version-manual.pdf"
    src "https://bio.informatik.uni-jena.de/repository/dist-snapshot-local/de/unijena/bioinf/ms/manual/$version/$manualName"
    dest buildDir.toPath().resolve("manual/$manualName").toFile()
    onlyIfModified true
    overwrite false
}


subprojects {
    //this is to keep classpath away from commandline because it may get too long for windows
    apply plugin: 'ManifestClasspath'

    jar {
        enabled = false
    }

    task distImage(type: AppImage, group: 'distribution') {
        dependsOn installDist, downloadManual, downloadCLP, downloadGLPK
        jpackagerBin = Paths.get(System.getProperty("java.home")).resolve('bin').resolve(OS.isWindows() ? 'jpackage.exe' : 'jpackage').toFile()
        mainClass = mainClassName
        outputDir = buildDir.toPath().resolve('distributions').toFile()
        winConsole = true

        jvmArgs = [
                '--illegal-access=permit',
                '--add-opens java.base/java.lang=ALL-UNNAMED',
                '--add-opens java.base/java.net=ALL-UNNAMED',
                '-javaagent:\\$APPDIR/agents-4.4.6-SNAPSHOT.jar',
        ]


        if (OS.isWindows()) {
            jvmArgs += ['-Djava.library.path=\\$APPDIR/..']
        } else {
            jvmArgs += ['-Djava.library.path=\\$APPDIR/../native']
        }

        doLast {
            File nativeLibsTarget
            File appRootTarget
            if (OS.isLinux()) {
                appRootTarget = outputDir.toPath().resolve(imageName).toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("lib/native").toFile()
            } else if (OS.isWindows()) {
                appRootTarget = outputDir.toPath().resolve(imageName).toFile()
                nativeLibsTarget = appRootTarget
            } else if (OS.isMacOsX()) {
                appRootTarget = outputDir.toPath().resolve("${imageName}.app/Contents").toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("native").toFile()
            } else {
                throw new RuntimeException("Could not detect OS for packaging!")
            }

            copy {
                from("${glpkPath}/$nativeLibs/") {
                    include('libglpk.so.40')
                    include('libglpk_java.so')
                }
                from("${clpPath}/$nativeLibs/")
                into(nativeLibsTarget)
            }
            copy {
                from("${distPath}") {
                    include('COPYING.txt')
                    include('LICENSE.txt')
                }
                from(downloadManual.outputs.files.singleFile)
                into(outputDir.toPath().resolve(imageName).toFile())
            }
        }
    }

    task distImageZip(dependsOn: distImage, group: 'distribution') {
        doFirst {
            def imageDir = distImage.getImageDir()
            def parentPath = imageDir.parentFile.toPath()
            def zipFile = parentPath.resolve("${imageDir.getName()}.zip")
            project.ant.zip(destfile: zipFile, duplicate: 'fail') {
                imageDir.eachFileRecurse { f ->
                    int mode = f.canExecute() ? 755 : 644
                    def relPath = parentPath.relativize(f.toPath()).toString()
                    zipfileset(dir: parentPath, includes: relPath, filemode: mode)
                }
            }
        }
    }

    task distInstaller(type: AppInstaller, dependsOn: distImage, group: 'distribution') {
        distImg = distImage
        types = [installerNameType]
        licenseFile = getRootProject().rootDir.toPath().resolve('jpackage').resolve('LICENSE-Full.txt').toFile()

    }

    task distribution { group = 'distribution' }

    distribution.dependsOn 'distImageZip'
    distribution.dependsOn 'distInstaller'
    artifactoryPublish.dependsOn 'distribution'
}

class AppImage extends DefaultTask {

    File jpackagerBin
    File outputDir
    String imageName
    String[] jvmArgs
    String[] args
    String version
    String mainClass
    String mainJarName
    File runtimeImageDirectory
    boolean winConsole
    Map<String, File> launchers

    AppImage() {
        imageName = project.name
        jvmArgs = []
        version = project.OS.isWindows() ? project.version.replace('-SNAPSHOT', '') : project.version
        winConsole = false
    }

    File getImageDir() {
        return outputDir.toPath().resolve(imageName).toFile()
    }

    @TaskAction
    def execute() {
        String[] p = ['--type', 'app-image']
        p += createParameters()
        project.exec {
            def c = buildCommand(p)
            println c
            commandLine(c)
        }
    }

    def buildCommand(String[] parameters) {
        if (project.OS.isWindows()) {
            //todo windows command line sucks!
            List<String> c = parameters as List
            c.add(0, "\"${jpackagerBin.absolutePath}\"")
            return c.toArray()
        } else {
            getLogger().lifecycle("${jpackagerBin.absolutePath} ${parameters.join(' ')}")
            return ['bash', '-e', '-c', """
                ${jpackagerBin.absolutePath} ${parameters.join(' ')}
                """]
        }
    }

    String[] createParameters() {
        def paras = [
                '--runtime-image', runtimeImageDirectory.absolutePath,
                '-i', project.tasks.getByName('installDist').outputs.files.singleFile.toPath().resolve('lib').toString(),
                '--dest', outputDir.toString(),
                '--name', imageName,
                '--app-version', version,
                '--main-class', mainClass,
                '--main-jar', mainJarName
        ]

        if (jvmArgs != null)
            for (String arg : jvmArgs)
//                paras +=['--java-options', arg,]
                paras += ['--java-options', "\"$arg\"",]

        if (args != null)
            for (String arg : args)
                paras += ['--arguments', "\"$arg\""]

        if (launchers != null)
            for (String name : launchers.keySet())
                paras += ["--add-launcher", "\"$name=${launchers.get(name)}\""]


        def iconDir = project.getRootProject().rootDir.toPath().resolve('icons')
        if (project.OS.isWindows()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.ico').toString()}"]
            if (winConsole)
                paras += ['--win-console']
        } else if (project.OS.isMacOsX()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.icns').toString()}"]
        } else if (project.OS.isLinux()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.png').toString()}"]
        } else {
            throw new IllegalArgumentException("Could not determine the OS to build on")
        }
        return paras
    }
}

abstract class AppInstaller extends DefaultTask {
    AppImage distImg
    String[] types
    File licenseFile


    boolean winDirChooser = true
    boolean winMenu = true
    String winMenuGroup = null
    boolean winShortcut
    boolean winPerUserInstall = false

    @TaskAction
    def execute() {
        String[] p = ['--type', types.join(',')]
        p += createParameters()
        project.exec {
            def c = distImg.buildCommand(p)
            println c
            commandLine(c)
        }
    }

    String[] createParameters() {
        String[] paras = []//distImg.createParameters()

        paras += [
                '--name', distImg.imageName,
            '--app-image', distImg.getImageDir().absolutePath,
            '--license-file', licenseFile.absolutePath,
//                '-o', image.outputDir.absolutePath,
//                '--version', image.version,
//                "--icon", "${project.getRootProject().rootDir.toPath().resolve('icons').resolve('sirius-icon.png').toString()}"
//                '--install-dirr'
        ]


        if (project.OS.isWindows()) {
            if (winDirChooser)
                paras += ['--win-dir-chooser'/*, winDirChooser ? '1' : '0'*/]
            if (winMenu)
                paras += ['--win-menu'/*, winMenu ? '1' : '0'*/]
            if (winMenuGroup != null && !winMenuGroup.isBlank())
                paras += ['--win-menu-group', "\"$winMenuGroup\""]
            if (winShortcut)
                paras += ['--win-shortcut']
            if (winPerUserInstall)
                paras += ['--win-per-user-install']
        } else if (project.OS.isMacOsX()) {
            //todo fill me
        } else if (project.OS.isLinux()) {
            //todo fill me
        } else {
            throw new IllegalArgumentException("Could not determine the OS to build on")
        }
        return paras
    }


}
