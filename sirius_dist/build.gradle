import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform

import java.nio.file.Paths

plugins {
    id 'org.beryx.runtime' version '1.11.4'
}

ext {
    OS = DefaultNativePlatform.currentOperatingSystem

    if (OS.isLinux()) {
        nativeLibs = 'l64'
        osName = 'linux64'
        zosName = 'linux'
        installerNameType = 'deb'
        installerAppendix = "_${version}-1_amd64.$installerNameType"
    } else if (OS.isWindows()) {
        nativeLibs = 'w64'
        osName = 'win64'
        zosName = 'win'
        installerNameType = 'msi'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType"
    } else if (OS.isMacOsX()) {
        nativeLibs = 'osx'
        osName = 'osx64'
        zosName = 'macosx'
        installerNameType = 'pkg'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType"
    }
}

task downloadJDK(type: Download) {
    String fname = "zulu${zulu_jre_version}-ca-fx-jdk${jre_version}-${zosName}_x64"
    String ext = ".${OS.isWindows() ? 'zip' : 'tar.gz'}";
    project.ext.set("jdkPath", getBuildDir().toPath().resolve(fname).toFile())


    src "https://bio.informatik.uni-jena.de/repository/list/ext-release-local/zulu/fx-jdk/${zulu_jre_version}/${fname + ext}"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname + ext).toFile()
    onlyIfModified true
    overwrite false
}

task extractJDK(type: Copy, dependsOn: downloadJDK) {
    def s = downloadJDK.outputs.files.singleFile
    println(s)
    if (s.getName().endsWith('.zip')) {
        outputs.file(s.absolutePath.replace('.zip', ''))
        from zipTree(s)
    } else {
        outputs.file(s.absolutePath.replace('.tar.gzip', ''))
        from tarTree(resources.gzip(s))
    }
    into buildDir
}

task createRuntimeImgs(dependsOn: extractJDK) {
    String[] baseModules = ['java.sql', 'java.logging', 'jdk.jsobject', 'java.xml', 'jdk.xml.dom', 'java.datatransfer',
                            'java.naming', 'java.prefs', 'java.instrument']
    String[] fxModules = baseModules +
            ['java.desktop', 'javafx.base', 'javafx.web', 'javafx.graphics', 'javafx.swing', 'javafx.controls']

    File jlink = jdkPath.toPath().resolve('bin').resolve(OS.isWindows()?'jlink.exe':'jlink').toFile()
    File outFX = buildDir.toPath().resolve('runtime').resolve("sirius-${jlink.toPath().getParent().getParent().getFileName().toString()}").toFile()
    File outheadl = Paths.get(outFX.absolutePath.replace('-fx-','-headless-')).toFile()
    outputs.files(outFX,outheadl)

    String[] args =  ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']

    doLast{
        exec{
            String[] c = [jlink.absolutePath,'--add-modules', "${baseModules.join(',')}", '--output', outheadl.absolutePath]
            commandLine(c + args)
        }
        exec{
            String[] c = [jlink.absolutePath,'--add-modules', "${fxModules.join(',')}", '--output', outFX.absolutePath]
            commandLine(c + args)
        }
    }
}




task downloadGLPK(type: Download) {
    project.ext.set("glpkPath", getBuildDir().toPath().resolve('glpk').toFile())
    String fname = "glpk-${project.glpk_lib_version}.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/glpk/$fname"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname).toFile()
    onlyIfModified true
    overwrite false
    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking GLPK...")
                from zipTree(outputs.files.singleFile)
                into buildDir
            }
        } else {
            getLogger().lifecycle("Unpacking GLPK SKIPPED")
        }
    }
}

task downloadCLP(type: Download) {
    project.ext.set("clpPath", getBuildDir().toPath().resolve('clp').toFile())
    String fname = "clp-${project.clp_lib_version}.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/clp/$fname"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname).toFile()
    onlyIfModified true
    overwrite false
    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking CPL...")
                from zipTree(outputs.files.singleFile)
                into buildDir

            }
        } else {
            getLogger().lifecycle("Unpacking CPL SKIPPED")
        }
    }
}


task downloadRuntimeImageFX(type: Download) {
    String fname = "sirius-zulu${zulu_jre_version}-ca-fx-jdk${jre_version}-${zosName}_x64.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/jre/${zulu_jre_version}/${fname}"
    dest getBuildDir().toPath().resolve('runtime').resolve(fname).toFile()
    onlyIfModified true
    overwrite false

    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking runtime image fx...")
                from zipTree(outputs.files.singleFile)
                into getBuildDir().toPath().resolve('runtime').toFile()

            }
        } else {
            getLogger().lifecycle("Unpacking runtime image fx SKIPPED")
        }
    }
}

task downloadRuntimeImageHeadless(type: Download) {
    String fname = "sirius-zulu${zulu_jre_version}-ca-headless-jdk${jre_version}-${zosName}_x64.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/jre/${zulu_jre_version}/${fname}"
    dest getBuildDir().toPath().resolve('runtime').resolve(fname).toFile()
    onlyIfModified true
    overwrite false

    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking runtime image headless...")
                from zipTree(outputs.files.singleFile)
                into getBuildDir().toPath().resolve('runtime').toFile()

            }
        } else {
            getLogger().lifecycle("Unpacking runtime image headless SKIPPED")
        }
    }
}

task downloadManual(type: Download, group: 'documentation') {
    String manualName = "manual-$version-manual.pdf"
    src "https://bio.informatik.uni-jena.de/repository/dist-snapshot-local/de/unijena/bioinf/ms/manual/$version/$manualName"
    dest buildDir.toPath().resolve("manual/$manualName").toFile()
    onlyIfModified true
    overwrite false
}

class AppImage extends DefaultTask {

    File jpackagerBin
    File outputDir
    String imageName
    String[] jvmArgs
    String[] args
    String version
    String mainClass
    String mainJarName
    File runtimeImageDirectory
    Map<String,File> launchers

    AppImage() {
        imageName = project.name
        jvmArgs = []
        version = project.version
    }

    File getImageDir() {
        return outputDir.toPath().resolve(imageName).toFile()
    }

    @TaskAction
    def execute() {
        String[] p = createSubcommand().plus(createParameters())
        project.exec {
            commandLine(buildCommand(p))
        }
    }

    def buildCommand(String[] parameters) {
        if (project.OS.isWindows()) {
            return [jpackagerBin.absolutePath, parameters.join(' ')]
        } else {
            getLogger().lifecycle("${jpackagerBin.absolutePath} ${parameters.join(' ')}")
            return ['bash', '-e', '-c', """
                ${jpackagerBin.absolutePath} ${parameters.join(' ')}
                """]
        }
    }
//                export JAVA_HOME=${jdkHome.absolutePath}

    String [] createSubcommand() {
        return ['--type','app-image']
    }

    String[] createParameters() {
        def paras = [
                '--runtime-image', runtimeImageDirectory.absolutePath,
                '-i', project.tasks.getByName('installDist').outputs.files.singleFile.toPath().resolve('lib').toString(),
                '--dest', outputDir.toString(),
                '--name', imageName,
                '--app-version', version,
                '--main-class', mainClass,
                '--main-jar', mainJarName
        ]

        if (jvmArgs !=  null)
            for (String arg : jvmArgs)
//                paras +=['--java-options', arg,]
                paras +=['--java-options', "\"$arg\"",]

        if (args !=  null)
            for (String arg : args)
                paras += ['--arguments', "\"$arg\""]

        if (launchers != null)
            for (String name : launchers.keySet())
                paras += ["--add-launcher", "\"$name=${launchers.get(name)}\""]

//        if (args != null)
//            paras += ['--arguments', "\"${args.join(' ')}\""]

        def iconDir = project.getRootProject().rootDir.toPath().resolve('icons')
        if (project.OS.isWindows()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.ico').toString()}"]
        } else if (project.OS.isMacOsX()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.icns').toString()}"]
        } else if (project.OS.isLinux()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.png').toString()}"]
        } else {
            throw new IllegalArgumentException("Could not determine the OS to build on")
        }
        return paras
    }

}

abstract class AppInstaller extends DefaultTask {
    AppImage image;

    @TaskAction
    def execute() {
        project.exec {
            commandLine(image.buildCommand(createParameters()))
        }
    }


    String[] createParameters() {
        def paras = [
                '--name', image.imageName,
                '--app-image', image.getImageDir().absolutePath,
//                '-o', image.outputDir.absolutePath,
//                '--version', image.version,
//                "--icon", "${project.getRootProject().rootDir.toPath().resolve('icons').resolve('sirius-icon.png').toString()}"
        ]
        return paras
    }


}

class LinuxInstaller extends AppInstaller {

}

class WindowsInstaller extends AppInstaller {


}

class MacInstaller extends AppInstaller {


}

subprojects {
    //this is to keep classpath away from commandline because it may get too long for windows
    apply plugin: 'ManifestClasspath'

    jar {
        enabled = false
    }

    task distImage(type: AppImage, group: 'distribution') {
        dependsOn installDist, downloadManual, downloadCLP, downloadGLPK
        jpackagerBin = Paths.get(System.getProperty("java.home")).resolve('bin').resolve('jpackage').toFile()
        mainClass = mainClassName
        outputDir = buildDir.toPath().resolve('distributions').toFile()

        jvmArgs = [
                '--illegal-access=permit',
                '--add-opens java.base/java.lang=ALL-UNNAMED',
                '--add-opens java.base/java.net=ALL-UNNAMED',
                '-Djava.library.path=\\$APPDIR/../native',
                '-javaagent:\\$APPDIR/agents-4.4.6-SNAPSHOT.jar',
        ]

        doLast {
//            File nativeLibsTarget
//            File appRootTarget
            /*if (OS.isLinux()) {
                appRootTarget = jpackageImage.outputs.files.singleFile.toPath().resolve(jpackageImage.getJpackageData().imageName).toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("lib/native").toFile()
            } else if (OS.isWindows()) {
                appRootTarget = jpackageImage.outputs.files.singleFile.toPath().resolve(jpackageImage.getJpackageData().imageName).toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("native").toFile()
            } else if (OS.isMacOsX()) {
                appRootTarget = jpackageImage.outputs.files.singleFile.toPath().resolve("${jpackageImage.getJpackageData().imageName}.app/Contents").toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("native").toFile()
            } else {
                throw new RuntimeException("Could not detect OS for packaging!")
            }*/

            def nativeLibsTarget = outputDir.toPath().resolve(imageName).resolve('lib').resolve('native').toFile()
            copy {
                from("${glpkPath}/$nativeLibs/") {
                    include('libglpk.so.40')
                    include('libglpk_java.so')
                }
                from("${clpPath}/$nativeLibs/")
                into(nativeLibsTarget)
            }
            copy {
                from("${distPath}") {
                    include('COPYING.txt')
                    include('LICENSE.txt')
                }
                from(downloadManual.outputs.files.singleFile)
                into(outputDir.toPath().resolve(imageName).toFile())
            }
        }
    }

    task distImageZip(dependsOn: distImage, group: 'distribution') {
        doFirst {
            def imageDir = distImage.getImageDir()
            def parentPath = imageDir.parentFile.toPath()
            def zipFile = parentPath.resolve("${imageDir.getName()}.zip")
            project.ant.zip(destfile: zipFile, duplicate: 'fail') {
                imageDir.eachFileRecurse { f ->
                    int mode = f.canExecute() ? 755 : 644
                    def relPath = parentPath.relativize(f.toPath()).toString()
                    zipfileset(dir: parentPath, includes: relPath, filemode: mode)
                }
            }
        }
    }

    task distImageLinuxInstaller(dependsOn: distImage, type: LinuxInstaller, group: 'distribution') {
        image = distImage
    }

    task distribution { group = 'distribution' }

//    if (OS.isLinux())
//        distribution.dependsOn 'distImageLinuxInstaller'
    distribution.dependsOn 'distImageZip'
    artifactoryPublish.dependsOn 'distribution'
}
