import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform

plugins {
    id 'org.beryx.runtime' version '1.11.4'
}

ext {
    OS = DefaultNativePlatform.currentOperatingSystem

    if (OS.isLinux()) {
        nativeLibs = 'l64'
        osName = 'linux64'
        zosName = 'linux'
        installerNameType = 'deb'
        installerAppendix = "_${version}-1_amd64.$installerNameType"
    } else if (OS.isWindows()) {
        nativeLibs = 'w64'
        osName = 'win64'
        zosName = 'win'
        installerNameType = 'msi'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType"
    } else if (OS.isMacOsX()) {
        nativeLibs = 'osx'
        osName = 'osx64'
        zosName = 'macosx'
        installerNameType = 'pkg'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType"
    }
}


task downloadGLPK(type: Download) {
    project.ext.set("glpkPath", getBuildDir().toPath().resolve('glpk').toFile())
    String fname = "glpk-${project.glpk_lib_version}.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/glpk/$fname"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname).toFile()
    onlyIfModified true
    overwrite false
    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking GLPK...")
                from zipTree(downloadGLPK.outputs.files.singleFile)
                into buildDir
            }
        } else {
            getLogger().lifecycle("Unpacking GLPK SKIPPED")
        }
    }
}

task downloadCLP(type: Download) {
    project.ext.set("clpPath", getBuildDir().toPath().resolve('clp').toFile())
    String fname = "clp-${project.clp_lib_version}.zip"

    src "https://bio.informatik.uni-jena.de/repository/list/dist-release-local/de/unijena/bioinf/clp/$fname"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname).toFile()
    onlyIfModified true
    overwrite false
    doLast {
        if (!state.getUpToDate()) {
            copy {
                getLogger().lifecycle("Unpacking CPL...")
                from zipTree(downloadCLP.outputs.files.singleFile)
                into buildDir

            }
        } else {
            getLogger().lifecycle("Unpacking CPL SKIPPED")
        }
    }
}

task downloadJDK(type: Download) {
    String fname = "zulu${zulu_jre_version}-ca-fx-jdk${jre_version}-${zosName}_x64"
    String ext = ".${OS.isWindows() ? 'zip' : 'tar.gz'}";
    project.ext.set("jdkPath", getBuildDir().toPath().resolve('fname').toFile())


    src "https://bio.informatik.uni-jena.de/repository/list/ext-release-local/zulu/fx-jdk/${zulu_jre_version}/${fname + ext}"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname + ext).toFile()
    onlyIfModified true
    overwrite false


    /*doLast {
        if (!state.getUpToDate()) {
            getLogger().lifecycle("Unpacking Zulu...")
            jdkPath.deleteDir()
            copy {
                def s = outputs.files.singleFile
                println(s)
                if (s.getName().endsWith('.zip'))
                    from zipTree(s)
                else
                    from tarTree(resources.gzip(s))
                into buildDir
            }
        } else {
            getLogger().lifecycle("Unpacking JDK SKIPPED")
        }
    }*/
}

task extractJDK(type: Copy, dependsOn: downloadJDK) {
    def s = downloadJDK.outputs.files.singleFile
    println(s)
    if (s.getName().endsWith('.zip')) {
        outputs.file(s.absolutePath.replace('.zip', ''))
        from zipTree(s)
    } else {
        outputs.file(s.absolutePath.replace('.tar.gzip', ''))
        from tarTree(resources.gzip(s))
    }
    into buildDir
}

task downloadJpackager(type: Download, dependsOn: extractJDK) {
    String fname = "jdk.packager-${zosName}"
    String ext = ".zip"

    project.ext.set("jpPath", getBuildDir().toPath().resolve(fname).toFile())

    if (OS.isWindows())
        project.ext.set("jpBin", jdkPath.toPath().resolve('bin').resolve('jpackager.exe').toFile())
    else
        project.ext.set("jpBin", jpPath.toPath().resolve('jpackager').toFile())

    src "https://bio.informatik.uni-jena.de/repository/ext-release-local/jpackager/$fname$ext"
    dest getBuildDir().toPath().resolve('tmp').resolve(fname + ext).toFile()
    onlyIfModified true
    overwrite false
    doLast {
        if (!state.getUpToDate()) {
            getLogger().lifecycle("Unpacking Jpackager...")
            delete(jpPath)
            mkdir(jpPath)
            copy {
                from zipTree(downloadJpackager.outputs.files.singleFile)
                into jpPath
            }
            if (OS.isWindows()) {
                getLogger().lifecycle("Moving Jpackager into JDK because of Windows -,-")
                copy {
                    from(jpPath) {
                        into(jdkPath.toPath().resolve('bin').toFile()) {
                            include 'jpackager.exe'
                        }
                        into(jdkPath.toPath().resolve('jmods').toFile()) {
                            include 'jpackager.jar'
                        }
                    }
                }

            }
        } else {
            getLogger().lifecycle("Unpacking JPackager SKIPPED")
        }
    }
}

task downloadManual(type: Download, group: 'documentation') {
    String manualName = "manual-$version-manual.pdf"
    src "https://bio.informatik.uni-jena.de/repository/dist-snapshot-local/de/unijena/bioinf/ms/manual/$version/$manualName"
    dest buildDir.toPath().resolve("manual/$manualName").toFile()
    onlyIfModified true
    overwrite false
}

class AppImage extends DefaultTask {

    File jpackagerBin
    File jdkHome
    String[] modules
    File outputDir
    String imageName
    String[] jvmArgs
    String[] args
    String version
    String mainClass
    String mainJarName

    AppImage() {
        imageName = project.name
        jvmArgs = []
        version = project.version
    }

    File getImageDir() {
        return outputDir.toPath().resolve(imageName).toFile()
    }

    @TaskAction
    def execute() {
        String[] p = createSubcommand().plus(createParameters())
        project.exec {
            commandLine(buildCommand(p))
        }
    }

    def buildCommand(String[] parameters) {
        if (project.OS.isWindows()) {
            return [jpackagerBin.absolutePath, parameters.join(' ')]
        } else {
            getLogger().lifecycle("${jpackagerBin.absolutePath} ${parameters.join(' ')}")
            return ['bash', '-e', '-c', """
                export JAVA_HOME=${jdkHome.absolutePath}
                ${jpackagerBin.absolutePath} ${parameters.join(' ')}
                """]
        }
    }

    String [] createSubcommand() {
        return ['create-image']
    }

    String[] createParameters() {
        def paras = [
                '--add-modules', String.join(',', modules),
                '-i', project.tasks.getByName('installDist').outputs.files.singleFile.toPath().resolve('lib').toString(),
                '-o', outputDir.toString(),
                '--name', imageName,
                '--version', version,
                '--class', mainClass,
                '--jvm-args', "\"${jvmArgs.join(' ')}\"",
                '--main-jar', mainJarName
        ]
        if (args != null)
            paras += ['--arguments', "\"${args.join(' ')}\""]

        def iconDir = project.getRootProject().rootDir.toPath().resolve('icons')
        if (project.OS.isWindows()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.ico').toString()}"]
        } else if (project.OS.isMacOsX()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.icns').toString()}"]
        } else if (project.OS.isLinux()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.png').toString()}"]
        } else {
            throw new IllegalArgumentException("Could not determine the OS to build on")
        }
        return paras
    }

}

abstract class AppInstaller extends DefaultTask {
    AppImage image;

    @TaskAction
    def execute() {
        project.exec {
            commandLine(image.buildCommand(createParameters()))
        }
    }


    String[] createParameters() {
        def paras = [
                '--name', image.imageName,
                '--app-image', image.getImageDir().absolutePath,
//                '-o', image.outputDir.absolutePath,
//                '--version', image.version,
//                "--icon", "${project.getRootProject().rootDir.toPath().resolve('icons').resolve('sirius-icon.png').toString()}"
        ]
        return paras
    }


}

class LinuxInstaller extends AppInstaller {

}

class WindowsInstaller extends AppInstaller {


}

class MacInstaller extends AppInstaller {


}

subprojects {
    apply plugin: 'ManifestClasspath'
    //this is to keep classpath away from commandline because it may get too long for windows
//    apply plugin: 'org.beryx.runtime'

    jar {
        enabled = false
    }

    task distImage(type: AppImage, group: 'distribution') {
        dependsOn downloadJpackager, installDist, downloadManual, downloadCLP, downloadGLPK
        jpackagerBin = jpBin
        jdkHome = jdkPath
        mainClass = mainClassName
        outputDir = buildDir.toPath().resolve('distributions').toFile()

        modules = [
                'java.sql',
                'java.desktop',
                'java.logging',
                'jdk.jsobject',
                'java.xml',
                'jdk.xml.dom',
                'java.datatransfer',
                'java.naming',
                'java.prefs',
                'java.instrument'
        ]
        jvmArgs = [
                '-javaagent:\\$APPDIR/app/agents-4.4.6-SNAPSHOT.jar',
                '-Djava.library.path=\\$APPDIR/native'
        ]

        doLast {
//            File nativeLibsTarget
//            File appRootTarget
            /*if (OS.isLinux()) {
                appRootTarget = jpackageImage.outputs.files.singleFile.toPath().resolve(jpackageImage.getJpackageData().imageName).toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("lib/native").toFile()
            } else if (OS.isWindows()) {
                appRootTarget = jpackageImage.outputs.files.singleFile.toPath().resolve(jpackageImage.getJpackageData().imageName).toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("native").toFile()
            } else if (OS.isMacOsX()) {
                appRootTarget = jpackageImage.outputs.files.singleFile.toPath().resolve("${jpackageImage.getJpackageData().imageName}.app/Contents").toFile()
                nativeLibsTarget = appRootTarget.toPath().resolve("native").toFile()
            } else {
                throw new RuntimeException("Could not detect OS for packaging!")
            }*/

            def nativeLibsTarget = outputDir.toPath().resolve(imageName).resolve("native").toFile()
            copy {
                from("${glpkPath}/$nativeLibs/") {
                    include('libglpk.so.40')
                    include('libglpk_java.so')
                }
                from("${clpPath}/$nativeLibs/")
                into(nativeLibsTarget)
            }
            copy {
                from("${distPath}") {
                    include('COPYING.txt')
                    include('LICENSE.txt')
                }
                from(downloadManual.outputs.files.singleFile)
                into(outputDir.toPath().resolve(imageName).toFile())
            }
        }
    }

    task distImageZip(dependsOn: distImage, group: 'distribution') {
        doFirst {
            def imageDir = distImage.getImageDir()
            def parentPath = imageDir.parentFile.toPath()
            def zipFile = parentPath.resolve("${imageDir.getName()}.zip")
            project.ant.zip(destfile: zipFile, duplicate: 'fail') {
                imageDir.eachFileRecurse { f ->
                    int mode = f.canExecute() ? 755 : 644
                    def relPath = parentPath.relativize(f.toPath()).toString()
                    zipfileset(dir: parentPath, includes: relPath, filemode: mode)
                }
            }
        }
    }

    task distImageLinuxInstaller(dependsOn: distImage, type: LinuxInstaller, group: 'distribution') {
        image = distImage
    }

    task distribution { group = 'distribution' }

//    if (OS.isLinux())
//        distribution.dependsOn 'distImageLinuxInstaller'
    distribution.dependsOn 'distImageZip'
    artifactoryPublish.dependsOn 'distribution'
}
