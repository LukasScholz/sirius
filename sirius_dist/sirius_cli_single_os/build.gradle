import org.apache.commons.configuration.PropertiesConfiguration
import org.apache.commons.configuration.PropertiesConfigurationLayout
import java.util.stream.Collectors

dependencies {
    compile project(':sirius_cli')
    compile "de.unijena.bioinf.ms:ft_glpk:$siriusVersion"
    compile group: 'org.slf4j', name: 'slf4j-jdk14', version: "$slf4j_version"
}

mainClassName = 'de.unijena.bioinf.ms.frontend.SiriusCLIApplication'

//auto generate profiles to store default values
// todo extent to also find Properties in the frontend module
task collectProfiles(type: Copy) {
    group = 'other'
    from configurations.runtime.resolve().stream().map { f ->
        zipTree(f)
                .matching {
                    include '*.auto.config'
                }
    }.collect(Collectors.toList())

    into "$buildDir/tmp/profiles"
}

collectProfiles.dependsOn('compileJava')

task collectClassMaps(type: Copy) {
    group = 'other'

    from configurations.runtime.resolve().stream().map { f ->
        zipTree(f)
                .matching {
                    include '*.class.map'
                }
    }.collect(Collectors.toList())

    into "$buildDir/tmp/class_maps"
}
collectClassMaps.dependsOn('compileJava')


task makeProfileTemplate() {
    group = 'other'
    outputs.file("$buildDir/tmp/profiles_concat/concat.profile")
    doLast {
        outputs.files.singleFile.withWriter { w ->
            // For each input file path
            tasks.collectProfiles.outputs.files.singleFile.listFiles().each { f ->
                // Get a reader for the input file
                f.withReader { r ->
                    // And write data from the input into the output
                    w << r << '\n'
                }
            }
        }
    }
}
makeProfileTemplate.dependsOn('collectProfiles')


task mergeClassMaps() {
    group = 'other'
    outputs.file("${projectDir}/src/main/resources/config_class.map");
    doLast {
        outputs.files.singleFile.delete()
        outputs.files.singleFile.withWriter { w ->
            // For each input file path
            tasks.collectClassMaps.outputs.files.singleFile.listFiles().each { f ->
                // Get a reader for the input file
                f.withReader { r ->
                    // And write data from the input into the output
                    w << r << '\n'
                }
            }
        }
    }
}
mergeClassMaps.dependsOn('collectClassMaps')

task collectDefaultProfile(type: Copy) {
    group = 'other'
    from zipTree(configurations.runtime.find { it.name.startsWith("chemistry_base") })
            .matching {
                include 'default.config'
            }
    into "$buildDir/tmp/profiles_source_default/"
}
collectDefaultProfile.dependsOn('compileJava')

task mergeTemplateWithDefaultProfile() {
    group = 'other'

    outputs.file("${projectDir}/src/main/resources/custom.config");

    doLast {
        println("Writing new merge profile to: " + outputs.files.singleFile)
        PropertiesConfiguration config = new PropertiesConfiguration()
        PropertiesConfigurationLayout layout = new PropertiesConfigurationLayout(config)
        layout.load(new InputStreamReader(new FileInputStream(
                tasks.makeProfileTemplate.outputs.files.singleFile
        )))

        Iterator<String> iterator = config.keys
        while (iterator.hasNext())
            println(iterator.next())


        Properties defaultProfile = new Properties()
        tasks.collectDefaultProfile.outputs.files.singleFile.listFiles().first()
                .withReader("UTF8", {
                    defaultProfile.load(it)
                })

        defaultProfile.entrySet().each { e ->
            if (config.containsKey(e.key))
                config.setProperty(e.key, e.value)
            else
                println("Deprecated Profile key: ${e.key}")
        }

        outputs.files.singleFile.delete()
        outputs.files.singleFile.withWriter {
            layout.save(it)
        }
    }
}
mergeTemplateWithDefaultProfile.dependsOn('makeProfileTemplate')
mergeTemplateWithDefaultProfile.dependsOn('collectDefaultProfile')
mergeTemplateWithDefaultProfile.dependsOn('mergeClassMaps')

task checkDefaultProfile() {
    group = 'other'
    doLast {
        Properties defaultProfile = new Properties()
        tasks.collectDefaultProfile.outputs.files.singleFile.listFiles().first()
                .withReader("UTF8", { defaultProfile.load(it) })


        Properties tmp = new Properties()
        tasks.mergeTemplateWithDefaultProfile.outputs.files.singleFile
                .withReader("UTF8", {
                    tmp.load(it)
                })
        defaultProfile.putAll(tmp)

        def errorCount = 0
        logger.lifecycle(System.lineSeparator() + "Checking for NULL values in Profile...")
        defaultProfile.keys().each { e ->
            def v = defaultProfile.getProperty(e);
            if (v == null || ((String) v).isEmpty()) {
                logger.warn("${e} is NULL!")
                errorCount++
            }
        }
//        if (errorCount > 0) {
//            logger.error("FAILED: $errorCount NULL values found!" + System.lineSeparator())
//            throw new GradleException("Error: There are NULL values in the default.config of chemistry base")
//        }
        logger.lifecycle("DONE: No NULL values found!" + System.lineSeparator())
    }
}
checkDefaultProfile.dependsOn('collectDefaultProfile')
checkDefaultProfile.dependsOn('mergeTemplateWithDefaultProfile')

distImage {
    imageName = 'sirius'
    mainClass = mainClassName
    mainJarName = getRootProject().getChildProjects().get('sirius_cli').tasks.getByName('jar').outputs.files.singleFile.getName()
}

publishing {
    publications {
        sirius(org.gradle.api.publish.maven.MavenPublication) {
            artifactId = "$name"
            groupId = "$group"
            artifact source: "${distImage.getImageDir().absolutePath}.zip", classifier: "$osName-headless", extension: 'zip'
//            artifact source: jpackage.getJpackageData().installerOutputDir.toPath().resolve(jpackage.getJpackageData().installerName + installerAppendix).toFile(), classifier: "$osName-headless", extension: installerNameType
        }
    }
}




/*
task runCLI(type: Exec, dependsOn: installLinux64Dist, group: 'application') {
    File command = project.tasks.installLinux64Dist.outputs.files.singleFile.toPath().resolve("bin/${project.appName}").toFile()
    commandLine([command.absolutePath])
}*/
