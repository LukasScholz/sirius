import org.apache.commons.configuration.PropertiesConfiguration
import org.apache.commons.configuration.PropertiesConfigurationLayout

import java.util.stream.Collectors



dependencies {
    compile project(':sirius_cli')
    compile group: 'org.slf4j', name: 'slf4j-jdk14', version: "$slf4j_version"
}

mainClassName = 'de.unijena.bioinf.ms.frontend.SiriusCLIApplication'
project.ext.set("type", ['console'])


jar {
    manifest {
        attributes 'Main-Class': mainClassName
    }
}

/*################### Windows release Stuff ################### */
project.type.each { t ->
    project.arch.each { a ->
        tasks.create("launch4j-$t-$a", edu.sc.seis.launch4j.tasks.Launch4jLibraryTask) {
            group = 'launch4j'
            mainClassName = project.mainClassName
            headerType = t
            jreRuntimeBits = a
            outfile = "${project.appName}-${t}-${a}.exe"
        }
    }
}


/*################### Build distributions ################### */
task distribute { group = 'distribution' }
distribute.dependsOn ':buildDoku'

distributions {
    project.arch.each { ar ->
        def n = "${project.linSuffix}${ar}"
        create(n, {
            baseName = "${project.appName}-$n-headless"
            contents {
                into('lib') {
                    from("build/install/${project.name}/lib") {
                        exclude libExclude
                    }
                    from("${project.glpkPath}/l${ar}/") {
                        include('libglpk.so.40')
                        include('libglpk_java.so')
                    }
                    from("${project.clpPath}/l${ar}/")
                }

                into('bin') {
                    from("build/install/${project.name}/bin") {
                        exclude("*.bat")
                    }
                    from("${project.distPath}") {
                        exclude('sirius-gui')
                    }
                    from("${getRootDir()}/LICENSE.txt")
                }
                into('doc') {
                    from(project.pdfManualPath)
                }
                into('doc/html') {
                    from("${project.manualPath}/build/html")
                }
            }
        })
        distribute.dependsOn "${n}DistZip"
        getTasks().findByPath("${n}DistZip").dependsOn ':downloadGLPK'
        getTasks().findByPath("${n}DistZip").dependsOn ':downloadCLP'
        getTasksByName("${n}DistTar", false).each { it.setEnabled(false) }
    }

    //crete win32And64 zip tasks
    project.arch.each { ar ->
        def n = "${project.winSuffix}${ar}"
        create(n, {

            baseName = "${project.appName}-$n-headless"
            contents {
                into('lib') {
                    from('build/launch4j/lib') {
                        exclude libExclude
                    }
                }
                from { "${project.glpkPath}/w${ar}/" }
                from("${project.clpPath}/w${ar}/")
                from("${project.distPath}") {
                    exclude('sirius-gui')
                }
                from { "${getRootDir()}/LICENSE.txt" }
                from('build/launch4j') {
                    include("*-${ar}.exe")
                }
                into('doc') {
                    from(project.pdfManualPath)
                }
                into('doc/html') {
                    from("${project.manualPath}/build/html")
                }
            }
        })
        distribute.dependsOn "${n}DistZip"
        getTasks().findByPath("${n}DistZip").dependsOn ':downloadGLPK'
        getTasks().findByPath("${n}DistZip").dependsOn ':downloadCLP'
        getTasks().findByPath("${n}DistZip").dependsOn 'createAllExecutables'
        getTasksByName("${n}DistTar", false).each { it.setEnabled(false) }
    }

    //create osx zip
    def n = "${project.macSuffix}64"
    create(n, {
        baseName = "${project.appName}-$n-headless"
        contents {
            into('lib') {
                from("build/install/${project.name}/lib") {
                    exclude libExclude
                }
                from("${project.glpkPath}/osx/")
                from("${project.clpPath}/osx/")
                exclude('*.zip')
            }

            into('bin') {
                from("build/install/${project.name}/bin") {
                    exclude("*.bat")
                }
                from("${project.distPath}") {
                    exclude('sirius-gui')
                }
                from("${getRootDir()}/LICENSE.txt")
            }
            into('doc') {
                from(project.pdfManualPath)
            }
            into('doc/html') {
                from("${project.manualPath}/build/html")
            }
        }
    })
    distribute.dependsOn "${n}DistZip"
    getTasks().findByPath("${n}DistZip").dependsOn ':downloadGLPK'
    getTasks().findByPath("${n}DistZip").dependsOn ':downloadCLP'
    getTasksByName("${n}DistTar", false).each { it.setEnabled(false) }

    project.getTasksByName("distTar", false).each { it.setEnabled(false) }
    project.getTasksByName("distZip", false).each { it.setEnabled(false) }

    linux32DistZip.dependsOn 'installDist'
    linux32DistTar.dependsOn 'installDist'
    installLinux32Dist.dependsOn 'installDist'

    linux64DistZip.dependsOn 'installDist'
    linux64DistTar.dependsOn 'installDist'
    installLinux64Dist.dependsOn 'installDist'

    win32DistZip.dependsOn 'createExe'
    win32DistTar.dependsOn 'createExe'
    installWin32Dist.dependsOn 'createExe'

    win64DistZip.dependsOn 'createExe'
    win64DistTar.dependsOn 'createExe'
    installWin64Dist.dependsOn 'createExe'
}

// what should be published
publishing {
    publications {
        sirius(MavenPublication) {
            artifactId = "${project.appName}"
            groupId = "$group"

            pom.withXml {}
            artifact source: win64DistZip, classifier: 'win64-headless', extension: 'zip'
            artifact source: win32DistZip, classifier: 'win32-headless', extension: 'zip'
            artifact source: linux32DistZip, classifier: 'linux32-headless', extension: 'zip'
            artifact source: linux64DistZip, classifier: 'linux64-headless', extension: 'zip'
            artifact source: osx64DistZip, classifier: 'osx64-headless', extension: 'zip'
        }

    }
}
artifactoryPublish.dependsOn 'distribute'

//auto generate profiles to store default values
// todo extent to also find Properties in the frontend module
task collectProfiles(type: Copy) {
    group = 'other'

    from configurations.runtime.resolve().stream().map { f ->
        zipTree(f)
                .matching {
                    include '*.auto.config'
                }
    }.collect(Collectors.toList())

    into "$buildDir/tmp/profiles"
}

collectProfiles.dependsOn('compileJava')

task collectClassMaps(type: Copy) {
    group = 'other'

    from configurations.runtime.resolve().stream().map { f ->
        zipTree(f)
                .matching {
                    include '*.class.map'
                }
    }.collect(Collectors.toList())

    into "$buildDir/tmp/class_maps"
}
collectClassMaps.dependsOn('compileJava')


task makeProfileTemplate() {
    group = 'other'
    outputs.file("$buildDir/tmp/profiles_concat/concat.profile")
    doLast {
        outputs.files.singleFile.withWriter { w ->
            // For each input file path
            tasks.collectProfiles.outputs.files.singleFile.listFiles().each { f ->
                // Get a reader for the input file
                f.withReader { r ->
                    // And write data from the input into the output
                    w << r << '\n'
                }
            }
        }
    }
}
makeProfileTemplate.dependsOn('collectProfiles')


task mergeClassMaps() {
    group = 'other'
    outputs.file("${projectDir}/src/main/resources/config_class.map");
    doLast {
        outputs.files.singleFile.delete()
        outputs.files.singleFile.withWriter { w ->
            // For each input file path
            tasks.collectClassMaps.outputs.files.singleFile.listFiles().each { f ->
                // Get a reader for the input file
                f.withReader { r ->
                    // And write data from the input into the output
                    w << r << '\n'
                }
            }
        }
    }
}
mergeClassMaps.dependsOn('collectClassMaps')

task collectDefaultProfile(type: Copy) {
    group = 'other'
    from zipTree(configurations.runtime.find { it.name.startsWith("chemistry_base") })
            .matching {
                include 'default.config'
            }
    into "$buildDir/tmp/profiles_source_default/"
}
collectDefaultProfile.dependsOn('compileJava')

task mergeTemplateWithDefaultProfile() {
    group = 'other'

    outputs.file("${projectDir}/src/main/resources/custom.config");

    doLast {
        println("Writing new merge profile to: " + outputs.files.singleFile)
        PropertiesConfiguration config = new PropertiesConfiguration()
        PropertiesConfigurationLayout layout = new PropertiesConfigurationLayout(config)
        layout.load(new InputStreamReader(new FileInputStream(
                tasks.makeProfileTemplate.outputs.files.singleFile
        )))

        Iterator<String> iterator = config.keys
        while (iterator.hasNext())
            println(iterator.next())


        Properties defaultProfile = new Properties()
        tasks.collectDefaultProfile.outputs.files.singleFile.listFiles().first()
                .withReader("UTF8", {
                    defaultProfile.load(it)
                })

        defaultProfile.entrySet().each { e ->
            if (config.containsKey(e.key))
                config.setProperty(e.key, e.value)
            else
                println("Deprecated Profile key: ${e.key}")
        }

        outputs.files.singleFile.delete()
        outputs.files.singleFile.withWriter {
            layout.save(it)
        }
    }
}
mergeTemplateWithDefaultProfile.dependsOn('makeProfileTemplate')
mergeTemplateWithDefaultProfile.dependsOn('collectDefaultProfile')
mergeTemplateWithDefaultProfile.dependsOn('mergeClassMaps')

task checkDefaultProfile() {
    group = 'other'

    doLast {
        Properties defaultProfile = new Properties()
        tasks.collectDefaultProfile.outputs.files.singleFile.listFiles().first()
                .withReader("UTF8", { defaultProfile.load(it) })


        Properties tmp = new Properties()
        tasks.mergeTemplateWithDefaultProfile.outputs.files.singleFile
                .withReader("UTF8", {
                    tmp.load(it)
                })
        defaultProfile.putAll(tmp)

        def errorCount = 0
        logger.lifecycle(System.lineSeparator() + "Checking for NULL values in Profile...")
        defaultProfile.keys().each { e ->
            def v = defaultProfile.getProperty(e);
            if (v == null || ((String) v).isEmpty()) {
                logger.warn("${e} is NULL!")
                errorCount++
            }
        }
//        if (errorCount > 0) {
//            logger.error("FAILED: $errorCount NULL values found!" + System.lineSeparator())
//            throw new GradleException("Error: There are NULL values in the default.config of chemistry base")
//        }
        logger.lifecycle("DONE: No NULL values found!" + System.lineSeparator())
    }
}
checkDefaultProfile.dependsOn('collectDefaultProfile')
checkDefaultProfile.dependsOn('mergeTemplateWithDefaultProfile')
//distribute.dependsOn('checkDefaultProfile')


task runCLI(type: Exec, dependsOn: installLinux64Dist, group: 'application') {
    File command = project.tasks.installLinux64Dist.outputs.files.singleFile.toPath().resolve("bin/${project.appName}").toFile()
    commandLine([command.absolutePath])
}